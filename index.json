
[{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/series/basic-algorithm/","section":"Series","summary":"","title":"Basic Algorithm","type":"series"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/basic-algorithm/","section":"Basic Algorithms","summary":"","title":"Basic Algorithms","type":"basic-algorithm"},{"content":" 1 基于比较的排序——Comparison Based Sorts # 从来没有最优秀的排序算法。我们只能找到相对最合适的一个。\n以下所有排序默认采用从升序，也就是 \\(a_{n-1}\u0026lt;a_{n}\\)\n1.1 Selection Sort # 一种很符合直觉的排序方法——将目前最小的值插到尚未排序部分的最前面。\n也就是说，对于如下的序列， $$ {{19| 3| 5| 2| 6| 8| 8}} $$ 我们首先找到最小的一个 $$ 19||3||5||{\\color{Red} 2}||6||8||8 $$ 再找到目前未排序的部分(这里显然是序列全部)，将2放到最前面 $$ {\\color{Red} 2} ||19||3||5||6||8||8 $$ 我们继续进行类似的操作，最终得到一个从小到大排序的序列 $$ 2||3||5||6||8||8||19 $$ 但在实际运用的过程中，对数据的直接移动时间开销很大(因为要将后续数据向前推)，并且可能导致数组越界，所以我们进行轻微修改，把将2移到未移动部分的最前面改为与未移动部分的第一项交换位置。也就是，首先找到最小值 $$ 19||3||5||{\\color{Red} 2}||6||8||8 $$ 再将之与第一项交换 $$ {\\color{Red} 19} ||3||5||{\\color{Red} 2}||6||8||8 \\longrightarrow {\\color{Red} 2} ||3||5||{\\color{Red} 19}||6||8||8 $$ 接着对第二项、第三项\u0026hellip;进行类似处理。这样操作了n次后，我们保证了前n项一定是有序的。\n我们根据这个思路很容易得到该算法的C++代码:\n#include \u0026lt;vector\u0026gt; using namespace std; void selectionSort(vector\u0026lt;int\u0026gt; \u0026amp;vec) { for (int i = 0; i \u0026lt; vec.size() - 1; i ++) { int minOff = i; // First see offset i as the minum for (int j = i + 1; j \u0026lt; vec.size(); j ++) { if (vec.at(minOff) \u0026gt; vec.at(j)) { minOff = j; } } int middle = vec.at(i); vec.at(i) = vec.at(minOff); vec.at(minOff) = middle; } } 这类排序的优点与缺点都十分显著：\n优点：直观，易于理解，不容易写错，并且空间复杂度低\n缺点：时间复杂度高(极端情况下有 $$ n+(n-1)+(n-2)+\u0026hellip; \\longrightarrow o(2^{n}) $$ 的时间复杂度)较高\n1.2 Bubble Sort # 这也是一种很直观的排序算法。我们将不断的遍历整个数组、对比两个相邻量之间的大小关系，直到有一次循环中我们发现没有对数组进行任何修改，也就是满足了递推关系 $$ a_1\\le a_2,a_2\\le a_3,a_3\\le a_4\\ \u0026hellip;\\ ,a_{n-1}\\le a_n $$ 我们便可推出 $$ a_1\\le a_2\\le a_3\\le a_4\\ \u0026hellip;\\ \\le a_{n-1}\\le a_n $$ 下面是算法运行过程的图示 $$ Original:\\ 19| 3| 5| 2| 6| 8| 8 \\ $$ $$ \\longrightarrow\\ {\\color{Red} 19} | {\\color{Green} 3} | 5| 2| 6| 8| 8 \\ $$\n$$ We\\ find\\ 19 \u0026gt; 3 \\ $$\n$$ \\longrightarrow\\ {\\color{Green} 3}|{\\color{Red} 19}| 5| 2| 6| 8| 8 \\ $$\n$$ 3|19| 5| 2| 6| 8| 8 \\ $$\n$$ \\longrightarrow\\ 3|{\\color{Red} 19}| {\\color{Green}5}| 2| 6| 8| 8 \\ $$\n$$ We\\ find\\ 19 \u0026gt; 5 \\ $$\n$$ \\longrightarrow\\ 3|{\\color{Green}5}|{\\color{Red} 19}| 2| 6| 8| 8 \\ $$\n$$ \u0026hellip;\\ \u0026hellip; $$\n我们可以再做一些优化。注意到，我们在交换中遇到的最大值一定会不断的被交换下去。因其比所有值都大，如上述例子的最大值19，在与3比较完后移到3的位置，再与5比，必然大于5。以此类推到其他一般情况，第一轮结束时一定可以确定最大值，并且位于最后一位。这意味着，第i轮排序结束后可以确定前(n - i + 1)项的最大值，并且有\\(a_{n - i + 1} \\le a_{n - i + 2}\\)。\n基于上述考虑，我们完成该算法的C++代码:\n#include \u0026lt;vector\u0026gt; using namespace std; void bubbleSort(vector\u0026lt;int\u0026gt; \u0026amp;vec) { for (int i = 0; i \u0026lt; vec.size() - 1; i ++) { for (int j = 0; j \u0026lt; vec.size() - 1 - i; j ++){ if (vec[j] \u0026gt; vec[j + 1]) { int middleNum = vec[j + 1]; vec[j + 1] = vec[j]; vec[j] = middleNum; } } } } 这类排序的优缺点同样十分显著\n优点：直观、不易写错，具有稳定性\n缺点：时间复杂度高，极端情况下仍然有与选择排序一样的复杂度\\(o(n^2)\\)。在实际工程实践中也是基本不用。\n1.3 Insertion Sort # 实现上有点像selecstion和Bubble的结合体。该排序算法进行以下操作 $$ 19||3||5||2||6||8||8 \\ \\longrightarrow {\\color{Red} 19}||{\\color{Green} 3}||5||2||6||8||8 \\ \\longrightarrow {\\color{Green} 3}||{\\color{Red} 19}||5||2||6||8||8 \\ $$ 现在我们确定了3,19这一部分一定是有序的。接下来我们看第三项，将之先与19比较： $$ {\\color{Purple} 3} ||{\\color{Purple} 19} ||5||2||6||8||8 \\ \\longrightarrow {\\color{Purple} 3}||{\\color{Red} 19}||{\\color {Green}5}||2||6||8||8 \\ \\longrightarrow {\\color{Purple} 3}||{\\color {Green}5}||{\\color{Red} 19}||2||6||8||8 \\ \\longrightarrow {\\color{Purple} 3}||{\\color {Purple}5}||{\\color{Purple} 19}||2||6||8||8 \\ $$ 我们注意到\\(3\u0026lt;5\\)，因此此时前面三项\\(3||5||19\\)一定是有序的。\n这实际上减少了很大一部分平均时间开销，因为我们确定前面所有n-1项在进行第n项排序的时候就已经是有序的。我们在将第n-1项移动的时候在移动到一个小于其项的后面的位置就可以停止继续判别，直接进行下一组判定。\n基于上述思想，我们完成相应的C++代码：\n#include \u0026lt;vector\u0026gt; using namespace std; void insertionSort(vector\u0026lt;int\u0026gt; \u0026amp;vec) { for (int i = 1; i \u0026lt; vec.size(); i ++) { for (int j = 0; j \u0026lt; i; j ++) { if (vec[i - j - 1] \u0026gt; vec[i - j]) { int middleNum = vec[i - j - 1]; vec[i - j - 1] = vec[i - j]; vec[i - j] = middleNum; } else { break; } } } return; } ","date":"30 April 2025","externalUrl":null,"permalink":"/basic-algorithm/chapter-one-basic-algorithm--sorting/","section":"Basic Algorithms","summary":"","title":"Chapter 1 Basic Algorithm  Sorting","type":"basic-algorithm"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/","section":"Hollow's Sky City","summary":"","title":"Hollow's Sky City","type":"page"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]